## 程序的机器级表示

1. 计算机执行`机器代码`，用字节序列`编码低级的操作`，包括处理数据，管理内存，读写存储设备上的数据，以及利用网络通信。
2. 编译器**基于**`编程语言的规则`，`目标机器的指令集`和`操作系统遵循的惯例`，经过一系列的阶段生成机器代码。
3. GCC C语言编译器以`汇编代码的形式`产生输出,**汇编代码是机器代码的文本表示**，给出程序中的每一条指令。然后，GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。

### 3.1 历史观点

1. Intel处理器系列俗称x86,经历了一个长期的，不断进化发展的过程。其设计都是后向兼容的。
2. IA32: Intel32位体系结构(Intel Architecture 32-bit)，x86-64的32位前身。
3. x86-64:IA32的64位扩展。

### 3.2 程序编码

+ `linux-> gcc -Og -o p p1.c p2.c`

  1. gcc指的是GCC C编译器

  2. -Og告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级。

     ```
     1. 因为使用较高级别的优化产生的代码会严重变形，以致于产生的机器代码和初始源代码之间的关系非常难以理解。所以使用-Og优化作为学习的工具。
     2. 从程序的性能上考虑, 实际工作中，较高级别的优化(-O1或-O2)被认为是较好的选择。
     ```

  3. 实际上gcc调用了一整套的程序，将源代码转化成了可执行代码。

     ```
     1. 首先,C预处理器扩展源代码，插入所有用#include命令指定的文件，并扩展所有用#define声明指定的宏。
     2. 其次,编译器会产生两个源文件的汇编代码，名字分别为p1.s和p2.s。
     3. 再次,汇编器将汇编代码转化成二进制目标代码文件p1.o, p2.o。
     4. 最后，链接器将两个目标代码文件与实现库函数(printf等)的代码合并，并产生最终的可执行代码文件p。
     
     目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。
     可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。
     ```

#### 3.2.1 机器级代码

1. 计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。

2. 对于机器级编程来说，两种抽象尤为重要。

   + 第一种抽象是由指令集体系结构或指令集架构(Instruction set architecture, ISA)来定义机器级程序的格式和行为。

     ```
     1. 它定义了处理器的状态，指令的格式，以及每条指令对状态的影响。
     2. 大多数的ISA,包括x86-64，将程序的行为描述成好像每条指令都是按顺序执行的，即一条指令结束后，下一条才开始。
     3. 处理器的硬件远比描述的精细复杂，它们并发的执行许多指令，但是客户以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。
     ```

   + 第二种抽象是机器级程序使用的内存地址是虚拟地址。

     ```
     1. 提供的内存模型看上去是一个非常大的字节数组。
     2. 存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来
     ```

3. 在整个编译过程中，编译器会完成大部分的工作，将把C语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。

4. 汇编代码表示非常接近于机器代码，与机器代码相比，汇编代码的主要特点是用可读性更多的文件格式表示。理解汇编代码与原始C代码之间的联系是理解计算机如何执行程序的关键一步。

5. x86-64的机器代码和原始C代码差别非常大，一些通常对C语言程序员隐藏的状态都是可见的。

   + `程序计数器`(简称"PC", 在x86-64中用%rip表示)给出将要执行的下一条指令在内存中的地址。

   + `整数寄存器文件`包含16个命名的位置, 分别存储64位的值。

     ```
     1. 这些寄存器可以存储地址(c语言的指针)或者整数数据
     2. 有的存储器被用来记录某些重要的程序状态
     3. 而其他的寄存器用来保存临时数据，例如过程中的参数和局部变量，以及函数的返回值。
     ```

   + `条件码寄存器`保存着最近执行算术或逻辑指令的状态信息。它们用来实现控制或者数据流中的条件编码，比如用来实现if和while语句。

   + 一组`向量寄存器`可以存放一个或多个整数或浮点数值。


6. 虽然C语言可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单的将内存看成一个很大的，按字节寻址的数组。

7. C语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。即使是对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针。甚至不区分指针和整数。

8. 程序内存包含: `程序的可执行机器代码`, `操作系统需要的一些信息`，`用来管理过程调用和返回的运行时栈`，以及`用户分配的内存块`(比如说用malloc库函数分配的)。

   ```
   1. 程序内存用虚拟地址来寻址。
   2. 在任意给定的时刻，只有有限的一部分虚拟地址被认为是合法的。
   3. 操作系统管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。
   
   例如,x86-64的虚拟地址是由64位的字来表示。在目前的实现中，这些地址的高16位必须设置为0，所以一个地址实际上能够制定的是2[48]或64TB范围内的一个字节。较为典型的程序只会访问几兆或几千兆字节的数据。
   ```

9. 一条机器指令只执行一个基本的操作。

   ```
   1. 执行将存放在寄存器中的两个数字相加，在存储器和寄存器之间传递数据，或是条件分支转移到新的指令地址等基本操作
   2. 编译器必须产生这些指令的序列，从而实现程序结构(求值，循环，过程调用，返回值等)
   ```

#### 3.2.2  机器代码示例

1. 定义文件mstore.c如下

   ```c
   long mult2(long, long);
   void multstore(long x, long y, long *dest) {
       long t = mult2(x, y);
       *dest = t;
   }
   ```

2.  使用`-S`选项 , 执行` linux-> gcc -Og -S mstore.c`, 则会生成汇编文件`mstore.s`

3. 汇编文件`mstore.s`的主要内容如下，下面代码的每一个都对应于一条机器指令。

   ```
   该部分代码已经去除了所有关于局部变量或数据类型的信息
   multsore:   
       pushq   %rbx
       movq    %rdx, %rbx
       call    mult2
       movq    %rax, (%rbx)
       popq    %rbx
       ret    
       
    pushq指令表示应该将寄存器%rbx的内容压入程序栈。
   ```

4. 使用`-c`选项，执行`linux-> gcc -Og -c mstore.c`, gcc会`编译并汇编`该代码，生成目标代码文件mstore.o,它是二进制格式的。无法直接查看。

   ```
   在文件mstore.o中有一段14字节的序列
   53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
   
   1. 这些就是上面列出的汇编指令对应的目标代码
   2. 所以可知，机器执行的程序就是一个字节序列，它对应一系列的的指令的编码。
   3. 机器对产生这些指令的源代码几乎一无所知。
   ```


5. 使用反汇编器(disassembler)查看机器代码文件的内容，这些程序会根据机器代码产生一种类似于汇编代码的格式。

   1. 在linux中，使用objdump来进行查看。

   2. 执行`linux> objdump -d mstore.o`, 得到如下内容

      ```
      0000000000000000 <multstore>:
      offset Bytes               Equivalent  assembly language
         0:	53                   	push   %rbx
         1:	48 89 d3             	mov    %rdx,%rbx
         4:	e8 00 00 00 00       	callq  9 <multstore+0x9>
         9:	48 89 03             	mov    %rax,(%rbx)
         c:	5b                   	pop    %rbx
         d:	c3                   	retq  
         
         1. 每组有1~5个字节。每组都是一条指令，右边是等价的汇编语言。
      ```

   3. 机器代码和它的反汇编表示的特性

      1. x86-64的指令长度从1到15个字节不等。

         ```
         常用的指令以及操作数较少的指令所需的字节较少，而那些不太常用或操作数较多的指令所需字节数较多。
         ```

      2. 设计指令格式的方式是: 从某个给定的位置开始，可以将字节唯一的解码成机器指令。

         ```
         例如只有指令`pushq %rbx`是以字节值53开头的。
         ```

      3. 反汇编器只是基于`机器代码文件中的字节序列`来确定汇编代码。

         ```
         它不需要访问该程序的源代码或汇编代码。
         ```

      4. 反汇编器使用的指令命名规则与GCC生成的汇编代码有细微的差别。

         ```
         1. 例如,省略了很多指令结尾的`q`。这些后缀是大小指示符在大多数情况中可以省略。
         2. 反汇编器给call和ret指令添加了`q`后缀，同样省略这些后缀也没有问题。
         ```

6. 生成实际可执行代码需要对一组目标代码文件运行链接器，而这一组目标文件必须含有一个main函数。

   1. 假设main.c如下

      ```
      #include <stdio.h>
      void multstore(long, long, long *);
      int main() {
          long d;
          multstore(2,3, &d);
          printf("2 * 3 --> %ld\n", d);
          return 0;
      }
      long mult2(long a, long b) {
          long s = a + b;
          return s;
      }
      ```

   2. 执行`linux> gcc -Og -o prog main.c mstore.c`, 文件prog不仅包含两个过程的代码，还包含用来启动和终止程序的代码,以及用来与操作系统交互的代码。

   3. 通过linux-> objcdump -d prog反汇编prog， 反汇编会抽取各种代码序列，包括下面这两段:

      ```
      000000000040058b <mult2>:
        40058b:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax
        40059F:	c3                   	retq   
      
      1 0000000000400540 <multstore>:
      2  400540:	53                   	push   %rbx
      3  400541:	48 89 d3                mov    %rdx,%rbx
      4  400544:	e8 f2 ff ff ff       	callq  40058b <mult2>
      5  400549:	48 89 03             	mov    %rax,(%rbx)
      6  40054c:	5b                   	pop    %rbx
      7  40054d:	c3                   	retq   
      8  40054e:	90
      9  40054f:	90
      ```

      1. 这段代码与与mstore.c反汇编产生的代码几乎一样。
      2. 主要区别在于:
         + 链接器将这段代码的地址移到了一段不同的地址范围中。
         + 链接器填上了callq指令调用函数mult2需要使用的地址。
         + 多了第8和9行，这两行没有具体的作用，只是为了使函数代码变为16字节，这使得就存储器系统性能而言，能更好的放置下一个代码块。

#### 3.2.3 关于格式的注解

1. 执行linux-> gcc -Og -S mstore.c 得到mstore.s,其完整内容如下

   ```
   .file   "mstore.c"
           .text
           .globl  multstore
           .type   multstore, @function
   multstore:
           pushq   %rbx
           movq    %rdx, %rbx
           call    mult2
           movq    %rax, (%rbx)
           popq    %rbx
           ret
           .size   multstore, .-multstore
           .ident  "GCC: (Ubuntu 4.8.1-2ubuntu1~12.04) 4.8.1"
           .section        .note.GNU-stack,"",@progbits
   ```

   所有以`.`开头的行都是指导汇编器和链接器工作的伪指令，可以忽略这些行。

2. 对于上面的内容，带解释的汇编代码如下:

   ```
   void multstore(long x, long y, long *dest)
   x in %rdi, y in %rsi, dest in %rdx
   
   1 mulstore:
   2   pushq   %rbx             Save %rbx
   3   movq    %rdx, %rbx       Copy dest to %rbx
   4   call    mult2            Call mult2(x,y)
   5   movq    %rax, (%rbx)     Store result in at *dest
   6   popq    %rbx             Restore %rbx
   7   ret                      Return
   ```

3. 我们表述的是ATT格式的编码，这是GCC,OBJDUMP和其他一些我们使用工具的默认格式。而Miscrosoft以及Intel的文档工具等，其汇编代码是Intel格式的。这两种格式在许多方面是不同的。【了解】

   ```
   1. ATT:根据"AT&T"命令的,"AT&T"是运营贝尔实验室多年的公司
   
   2. Intel格式汇编代码, linux-> gcc -Og -S -masm=intel mstore.c
    mulstore:
      push   rbx             
      mov    rdx, rbx      
      call   mult2            
      mov    QWORD PTR [rbx], rax     
      pop    rbx            
      ret                    
   ```

### 3.3 数据格式

由于是从16位的体系结构扩展到32位上，所以Intel用术语"字(word)"来表示16位数据类型。

x86-64指令集同样包括完成的针对字节，字和双字的指令

```
c声明       Intel数据类型   汇编代码后缀    大小(字节)
char        字节           b               1
short       字             w               2
int         双字           l               4
long        四字           q               8
char*       四字           q               8
float       单精度          s              4
double      双精度          l               8
```

数据传送指令有4个变种: movb(传入字节),movw(传送字), movl(传送双字), movq(传送四字)

汇编代码中使用后缀`l`来表示4字节整数和8字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。

### 3.4 访问信息





